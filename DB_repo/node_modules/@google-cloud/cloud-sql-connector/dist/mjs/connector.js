// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { createServer } from 'node:net';
import { promisify } from 'node:util';
import { CloudSQLInstance } from './cloud-sql-instance.js';
import { getSocket } from './socket.js';
import { IpAddressTypes } from './ip-addresses.js';
import { AuthTypes } from './auth-types.js';
import { SQLAdminFetcher } from './sqladmin-fetcher.js';
import { CloudSQLConnectorError } from './errors.js';
// Internal mapping of the CloudSQLInstances that
// adds extra logic to async initialize items.
class CloudSQLInstanceMap extends Map {
    async loadInstance({ ipType, authType, instanceConnectionName, sqlAdminFetcher, }) {
        // in case an instance to that connection name has already
        // been setup there's no need to set it up again
        if (this.has(instanceConnectionName)) {
            const instance = this.get(instanceConnectionName);
            if (instance.authType && instance.authType !== authType) {
                throw new CloudSQLConnectorError({
                    message: `getOptions called for instance ${instanceConnectionName} with authType ${authType}, ` +
                        `but was previously called with authType ${instance.authType}. ` +
                        'If you require both for your use case, please use a new connector object.',
                    code: 'EMISMATCHAUTHTYPE',
                });
            }
            return;
        }
        const connectionInstance = await CloudSQLInstance.getCloudSQLInstance({
            ipType,
            authType,
            instanceConnectionName,
            sqlAdminFetcher: sqlAdminFetcher,
        });
        this.set(instanceConnectionName, connectionInstance);
    }
    getInstance({ instanceConnectionName, authType, }) {
        const connectionInstance = this.get(instanceConnectionName);
        if (!connectionInstance) {
            throw new CloudSQLConnectorError({
                message: `Cannot find info for instance: ${instanceConnectionName}`,
                code: 'ENOINSTANCEINFO',
            });
        }
        else if (connectionInstance.authType &&
            connectionInstance.authType !== authType) {
            throw new CloudSQLConnectorError({
                message: `getOptions called for instance ${instanceConnectionName} with authType ${authType}, ` +
                    `but was previously called with authType ${connectionInstance.authType}. ` +
                    'If you require both for your use case, please use a new connector object.',
                code: 'EMISMATCHAUTHTYPE',
            });
        }
        return connectionInstance;
    }
}
// The Connector class is the main public API to interact
// with the Cloud SQL Node.js Connector.
export class Connector {
    constructor(opts = {}) {
        this.instances = new CloudSQLInstanceMap();
        this.sqlAdminFetcher = new SQLAdminFetcher({
            loginAuth: opts.auth,
            sqlAdminAPIEndpoint: opts.sqlAdminAPIEndpoint,
            universeDomain: opts.universeDomain,
        });
        this.localProxies = new Set();
        this.sockets = new Set();
    }
    // Connector.getOptions is a method that accepts a Cloud SQL instance
    // connection name along with the connection type and returns an object
    // that can be used to configure a driver to be used with Cloud SQL. e.g:
    //
    // const connector = new Connector()
    // const opts = await connector.getOptions({
    //   ipType: 'PUBLIC',
    //   instanceConnectionName: 'PROJECT:REGION:INSTANCE',
    // });
    // const pool = new Pool(opts)
    // const res = await pool.query('SELECT * FROM pg_catalog.pg_tables;')
    async getOptions({ authType = AuthTypes.PASSWORD, ipType = IpAddressTypes.PUBLIC, instanceConnectionName, }) {
        const { instances } = this;
        await instances.loadInstance({
            ipType,
            authType,
            instanceConnectionName,
            sqlAdminFetcher: this.sqlAdminFetcher,
        });
        return {
            stream() {
                const cloudSqlInstance = instances.getInstance({
                    instanceConnectionName,
                    authType,
                });
                const { instanceInfo, ephemeralCert, host, port, privateKey, serverCaCert, serverCaMode, dnsName, } = cloudSqlInstance;
                if (instanceInfo &&
                    ephemeralCert &&
                    host &&
                    port &&
                    privateKey &&
                    serverCaCert) {
                    const tlsSocket = getSocket({
                        instanceInfo,
                        ephemeralCert,
                        host,
                        port,
                        privateKey,
                        serverCaCert,
                        serverCaMode,
                        dnsName,
                    });
                    tlsSocket.once('error', async () => {
                        await cloudSqlInstance.forceRefresh();
                    });
                    tlsSocket.once('secureConnect', async () => {
                        cloudSqlInstance.setEstablishedConnection();
                    });
                    return tlsSocket;
                }
                throw new CloudSQLConnectorError({
                    message: 'Invalid Cloud SQL Instance info',
                    code: 'EBADINSTANCEINFO',
                });
            },
        };
    }
    async getTediousOptions({ authType, ipType, instanceConnectionName, }) {
        if (authType === AuthTypes.IAM) {
            throw new CloudSQLConnectorError({
                message: 'Tedious does not support Auto IAM DB Authentication',
                code: 'ENOIAM',
            });
        }
        const driverOptions = await this.getOptions({
            authType,
            ipType,
            instanceConnectionName,
        });
        return {
            async connector() {
                return driverOptions.stream();
            },
            // note: the connector handles a secured encrypted connection
            // with that in mind, the driver encryption is disabled here
            encrypt: false,
        };
    }
    // Connector.startLocalProxy is an alternative to Connector.getOptions that
    // creates a local Unix domain socket to listen and proxy data to and from a
    // Cloud SQL instance. Can be used alongside a database driver or ORM e.g:
    //
    // const path = resolve('.s.PGSQL.5432'); // postgres-required socket filename
    // const connector = new Connector();
    // await connector.startLocalProxy({
    //   instanceConnectionName,
    //   ipType: 'PUBLIC',
    //   listenOptions: {path},
    // });
    // const datasourceUrl =
    //  `postgresql://${user}@localhost/${database}?host=${process.cwd()}`;
    // const prisma = new PrismaClient({ datasourceUrl });
    async startLocalProxy({ authType, ipType, instanceConnectionName, listenOptions, }) {
        const { stream } = await this.getOptions({
            authType,
            ipType,
            instanceConnectionName,
        });
        // Opens a local server that listens
        // to the location defined by `listenOptions`
        const server = createServer();
        this.localProxies.add(server);
        /* c8 ignore next 3 */
        server.once('error', err => {
            console.error(err);
        });
        // When a connection is established, pipe data from the
        // local proxy server to the secure TCP Socket and vice-versa.
        server.on('connection', c => {
            const s = stream();
            this.sockets.add(s);
            this.sockets.add(c);
            c.pipe(s);
            s.pipe(c);
        });
        const listen = promisify(server.listen);
        await listen.call(server, {
            path: listenOptions.path,
            readableAll: listenOptions.readableAll,
            writableAll: listenOptions.writableAll,
        });
    }
    // Clear up the event loop from the internal cloud sql
    // instances timeout callbacks that refreshs instance info.
    //
    // Also clear up any local proxy servers and socket connections.
    close() {
        for (const instance of this.instances.values()) {
            instance.cancelRefresh();
        }
        for (const server of this.localProxies) {
            server.close();
        }
        for (const socket of this.sockets) {
            socket.destroy();
        }
    }
}
//# sourceMappingURL=connector.js.map